use "./std/VecT.wapl"
use "./std/Slice.wapl"
use "./std/Iterator.wapl"
declare strcmp(ptr:char, ptr:char):i32;

struct String{
    ptr:char data,
    i64 len,
    i64 cap,
}
struct StrSlice{
    ptr:char data,
    i64 len,
}

fn StrSlice_new(ptr:char data,i64 len):StrSlice{
    #=(new,_,StrSlice);
    =(.(new,data),data);
    =(.(new,len),len);
    return new;
}



fn String_new(i64 capa):String{
    #=(v,_,String);
    #=(vp,&_(v),ptr:String);
    #=(d,malloc(+(capa,1),char),ptr:char);
    =(val(->(vp,data)),d);
    =(val(->(vp,len)),0);
    =(val(->(vp,cap)),capa);
    return v;
}

fn String_strlen(ptr:char c):i64{
    #=(i,0,i64);
    warpto(LoopStart);
    point LoopStart;
    warptoif(==([](c,i),'\0'),Break,InLoop);
    point InLoop;
        =(i,+(i,1));
    warpto(LoopStart);
    point Break;
    return i;
}

fn StrSlice_from(ptr:char c):StrSlice{
    #=(c_len,String_strlen(c),i64);
    return StrSlice_new(c,c_len);
}

fn String_from(ptr:char c):String{
    #=(v,_,String);
    #=(vp,&_(v),ptr:String);
    #=(c_len,String_strlen(c),i64);
    #=(d,malloc(+(c_len,1),char),ptr:char);
    =(val(->(vp,data)),d);
    =(val(->(vp,len)),c_len);
    =(val(->(vp,cap)),c_len);
    memcpy(val(->(vp,data)),c,c_len);
    =([](val(->(vp,data)),val(->(vp,len))),'\0')
    return v;
}
fn String_from_with_len(ptr:char c,i64 len):String{
    #=(v,_,String);
    #=(vp,&_(v),ptr:String);
    #=(c_len,len,i64);
    #=(d,malloc(+(c_len,1),char),ptr:char);
    =(val(->(vp,data)),d);
    =(val(->(vp,len)),c_len);
    =(val(->(vp,cap)),c_len);
    memcpy(val(->(vp,data)),c,c_len);
    =([](val(->(vp,data)),val(->(vp,len))),'\0')
    return v;
}

fn String_push(&mut:String &self,&:String value):ptr:String{
    #=(needed, +(_>(&self,len),_>(value,len)),i64);
    loopif:capaover(<(_>(&self,cap),+(needed,1))){
        #=(newcap,*( needed, 2 ),i64);
        =(_>(&self,data),realloc(_>(&self,data), +( newcap, 1),char));
        =(_>(&self,cap),newcap);
        warpto(break-capaover);
    }
    memcpy(ptr_add(_>(&self,data),_>(&self,len)), _>(value,data), _>(value,len));
    =(_>(&self,len),needed);
    =([](val(->(&self,data)),val(->(&self,len))),'\0');
    return &self;
}

fn String_get(String self,i64 indx):char{
    return [](.(self,data),indx);
}

fn String_free(ptr:String &self){
    free(_>(&self,data));
    =(val(->(&self,len)),0);
    =(val(->(&self,cap)),0);
}

fn str_cmp(ptr:char str1, ptr:char str2):i64{
    return as_i64(strcmp(str1,str2));
}

fn String_cmp(String string1, String string2):i64{
    return as_i64(strcmp(.(string1,data),.(string2,data)));
}

fn str_eq(ptr:char str1, ptr:char str2):bool{
    return ==(strcmp(str1,str2),0s);
}

fn String_to_VecT(String string):VecT{
    return VecT_from(.(string,data),1,.(string,len));
}

fn String_clone(String string):String{
    #=(clone,_,String);
    =(.(clone,len),.(string,len));
    =(.(clone,cap),.(string,cap));
    #=(d, malloc(+(.(string,cap),1),char),*:char);
    memcpy(d,.(string,data),+(.(string,len),1));
    =(.(clone,data),pmove(d));
    return clone;
}

fn String_as_str(String string):ptr:char{
    return .(string,data);
}
fn StrSlice_as_str(StrSlice str):ptr:char{
    return .(str,data);
}

fn String_as_StrSlice(String string):StrSlice{
    return StrSlice_new(String_as_str(string),.(string,len));
}

fn StrSlice_to_String(StrSlice str):String{
    return String_from_with_len(StrSlice_as_str(str),.(str,len));
}

fn is_space(char c):bool{
    return ||(||(||(==(c,' '),==(c,'\n')),==(c,'\t')),==(c,'\r'));
}

fn str_trim(ptr:char str):StrSlice{
    #=(start,0,i64);
    // 前方トリム
    loopif:start(true){
        #=(c,[](str,start),char);
        if(is_space(c)){
            =(start,+(start,1));
        }else{
            warpto(break-start);
        }
    }
    #=(end,String_strlen(ptr_add(str,start)),i64);
    // 後方トリム
    loopif:end(>(end,start)){
        #=(c,[](ptr_add(str,start),-(end,1)),char);
        if(is_space(c)){
            =(end,-(end,1));
        }else{
            warpto(break-end);
        }
    }
    #=(slice,StrSlice_new(
        ptr_add(str,start),
        end
    ),
    StrSlice);
    return slice;
}

fn StrSlice_trim(StrSlice str):StrSlice{
    return str_trim(StrSlice_as_str(str));
}

fn String_trim(String string):String{
    #=(trimedstr,str_trim(String_as_str(string)),StrSlice);
    return String_from_with_len(.(trimedstr,data),.(trimedstr,len));
}

fn StrSlice_iter(StrSlice str):Iterator{
    return iter(StrSlice_as_str(str),ptr_add(StrSlice_as_str(str),.(str,len)),sizeof(char));
}
fn String_iter(String string):Iterator{
    #=(str,String_as_StrSlice(string),StrSlice);
    return StrSlice_iter(str);
}

fn String_split_whitespace(String src):VecT{
    #=(vec_strslice,VecT_new(sizeof(StrSlice),1),VecT);
    #=(index,0,i64);
    #=(part_len,0,i64);
    #=(src_str,String_as_str(src),ptr:char);
    #=(start,src_str,ptr:char);
    #=(it,String_iter(src),Iterator);
    loopif:add_unsafe(is_some(iter_peek(&_(it)))){
        #=(c,*_(unwrap(iter_next(&_(it))),char),char);
        =(index,+(index,1));
        if(is_space(c)){
            if(>(part_len,0)){
                VecT_push(&_(vec_strslice),&_(StrSlice_new(start,part_len)));
            }
            =(part_len,0);
            =(start,ptr_add(src_str,index)); // 空白の終わりの次のとこを次のstartにする
            warpto(continue-add_unsafe);
        }
        =(part_len,+(part_len,1));
    }
    if(>(part_len,0)){
        VecT_push(&_(vec_strslice),&_(StrSlice_new(start,part_len)));
    }
    return vec_strslice;
}

fn String_split(String src,char key):VecT{
    #=(vec_strslice,VecT_new(sizeof(StrSlice),1),VecT);
    #=(index,0,i64);
    #=(part_len,0,i64);
    #=(src_str,String_as_str(src),ptr:char);
    #=(start,src_str,ptr:char);
    #=(it,String_iter(src),Iterator);
    loopif:add_unsafe(is_some(iter_peek(&_(it)))){
        #=(c,*_(unwrap(iter_next(&_(it))),char),char);
        =(index,+(index,1));
        if(==(c,key)){
            if(>(part_len,0)){
                VecT_push(&_(vec_strslice),&_(StrSlice_new(start,part_len)));
            }
            =(part_len,0);
            =(start,ptr_add(src_str,index)); // 空白の終わりの次のとこを次のstartにする
            warpto(continue-add_unsafe);
        }
        =(part_len,+(part_len,1));
    }
    if(>(part_len,0)){
        VecT_push(&_(vec_strslice),&_(StrSlice_new(start,part_len)));
    }
    return vec_strslice;
}