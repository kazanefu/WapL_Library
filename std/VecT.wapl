use "./std/Iterator.wapl"

struct VecT{
    ptr:T data,
    isize elem_size,
    isize len,
    isize cap,
}

fn VecT_new(isize e_size,isize capa):VecT{
    #=(v,_,VecT);
    #=(vp,&_(v),ptr:VecT);
    #=(d,malloc(*(e_size,capa),T),ptr:T);
    =(val(->(vp,data)),d);
    =(val(->(vp,elem_size)),e_size);
    =(val(->(vp,len)),0_);
    =(val(->(vp,cap)),capa);
    return v;
}

fn VecT_push(ptr:VecT &self,ptr:T value):ptr:T{
    warptoif(==(_>(&self,cap),_>(&self,len)),capaover,push);
    point capaover;
    =(val(->(&self,data)),realloc(_>(&self,data),*(_>(&self,elem_size),*(+(_>(&self,cap),1_),2_)),T));
    =(val(->(&self,cap)),*(+(_>(&self,cap),1_),2_));
    warpto(push);
    point push;
    memcpy(ptr_add(_>(&self,data),*(_>(&self,len),_>(&self,elem_size))),value,_>(&self,elem_size));
    =(val(->(&self,len)),+(_>(&self,len),1_));
    return value;
}

fn VecT_get(VecT self,isize indx):ptr:T{
    return ptr_add(.(self,data),*(indx,.(self,elem_size)));
}

fn VecT_free(ptr:VecT &self){
    free(_>(&self,data));
    =(val(->(&self,len)),0_);
    =(val(->(&self,cap)),0_);
}

fn VecT_from(&:T srcData,isize e_size, isize size):VecT{
    #=(v,_,VecT);
    #=(vp,&_(v),ptr:VecT);
    #=(d,malloc(*(e_size,size),T),*:T);
    memcpy(d,srcData,*(e_size,size));
    =(val(->(vp,data)),pmove(d));
    =(val(->(vp,elem_size)),e_size);
    =(val(->(vp,len)),size);
    =(val(->(vp,cap)),size);
    return v;    
}

fn VecT_connect(ptr:VecT &self,ptr:VecT value):ptr:VecT{
    #=(newlen,+(_>(&self,len),_>(value,len)),isize);
    #=(needed, *(newlen, _>(&self,elem_size)),isize);
    loopif:capaover(<=(_>(&self,cap),newlen)){
        #=(newcap,*( newlen, 2_ ),isize);
        =(_>(&self,data),realloc(_>(&self,data), *(newcap,_>(&self,elem_size)),T));
        =(_>(&self,cap),newcap);
        warpto(break-capaover);
    }
    memcpy(ptr_add(_>(&self,data),*(_>(&self,len),_>(&self,elem_size))),_>(value,data),*(_>(value,len),_>(value,elem_size)));
    =(_>(&self,len),newlen);
    return value;
}

fn VecT_rangei64(i64 start,i64 end,i64 step):VecT{
    #=(v,VecT_new(8_,as(/(-(end,start),step),isize)),VecT);
    #=(i,start,i64);
    loopif:(<(i,end)){
        VecT_push(&_(v),&_(i));
        =(i,+(i,step));
    }
    return v;
}

fn VecT_iter(VecT vec):Iterator{
    return iter(.(vec,data),VecT_get(vec,.(vec,len)),.(vec,elem_size));
}